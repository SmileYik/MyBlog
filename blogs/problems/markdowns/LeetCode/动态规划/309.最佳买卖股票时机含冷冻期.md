[跳转到题解](#题解)

309. 最佳买卖股票时机含冷冻期

难度：中等

给定一个整数数组prices，其中第 <em> </em>prices[i] 表示第 <em>i</em> 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。


**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。



**示例 1:**

```
输入: prices = [1,2,3,0,2]
输出: 3
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```


**示例 2:**

```
输入: prices = [1]
输出: 0

```

**提示：**

- 1 <= prices.length <= 5000
- 0 <= prices[i] <= 1000


给定一个整数数组prices，其中第 <em> </em>prices[i] 表示第 <em>i</em> 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。


**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。



**示例 1:**

```
输入: prices = [1,2,3,0,2]
输出: 3
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```


**示例 2:**

```
输入: prices = [1]
输出: 0

```

**提示：**

- 1 <= prices.length <= 5000
- 0 <= prices[i] <= 1000


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

### 题解

[跳转到题目](#page)

### 题解1

类似于 **买卖股票的最佳时机 II**, 不过这一次是带有一个限制条件, 就是抛出股票后有一天的冷冻期,
所以做法差不多但是还是有一点点区别.

如果只有一天的股票价格, 那么利润一定是0, 如果你买入的话那么利润为负数, 目标是获取最大利润, 那么
这时候不买, 那么利润就是最大的了.

如果只有两天的股票价格, 那么利润一定是0, 或者是第二天股票价格减去第一天股票价格.

如果有三天及以上天数的股票价格, 我们不妨记录下每天持有股票或者是没有持有股票情况下的利润最大值,
第三天的未持有股票的利润最大值为 max(第二天(昨天)未持有股票的利润最大值, 第二天(昨天)持有股票
的利润最大值加上今天抛售获得的利润之和); 持有股票的利润最大值为 max(第二天(昨天)持有股票的利润
最大值, 第一天(前天)未持有股票的利润最大值减去今天买股票花出去的成本之差).

可以转移成以下状态方程:

$$
f(n, k) =
    \begin{cases}
        0, & \text{$n = 0$, $k =0$} \\\\[2ex]
        -prices[0], & \text{$n = 0, k = 1$} \\\\[2ex]
        max\\{f(n - 1, 0), f(n - 1, 1) + prices[n]\\}, & \text{$n \geq 1, k = 0$} \\\\[2ex]
        max\\{f(n - 1, 0), f(n - 1, 1)\\}, & \text{$n = 1, k = 0$} \\\\[2ex]
        max\\{f(n - 1, 1), f(n - 2, 0) - prices[n]\\}, & \text{$n \geq 2, k = 1$}
    \end{cases}
$$

```
class Solution {
    public int maxProfit(int[] prices) {
        if (prices.length == 1) {
            return 0;
        } else if (prices.length == 2) {
            return Math.max(0, prices[1] - prices[0]);
        }
        int[][] dp = new int[prices.length][2];
        // 初始化
        dp[0][1] = -prices[0];
        dp[1][0] = Math.max(0, dp[0][1] + prices[1]);
        dp[1][1] = Math.max(dp[0][1], -prices[1]);
        for (int i = 2; i < prices.length; ++i) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 2][0] - prices[i]);
        }
        return dp[prices.length - 1][0];
    }
}
```
