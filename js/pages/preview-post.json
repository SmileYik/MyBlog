[{"markdown":"[原贴](https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xo566j/)\n\n给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` ，判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。\n\n**叶子节点** 是指没有子节点的节点。\n\n提示：\n+ 树中节点的数目在范围 `[0, 5000]` 内\n+ $-1000 <= Node.val <= 1000$\n+ $-1000 <= targetSum <= 1000$\n","time":"2021-04-05 22:40:58","title":"路径总和","url":"./post.html?BinaryTree=umvdbe"},{"markdown":"[原贴](https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xoxzgv/)\n\n给定一个二叉树, 判断他是否镜像对称的.\n\n例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。\n\n        1\n       / \\\n      2   2\n     / \\ / \\\n","time":"2021-04-05 21:59:02","title":"对称二叉树","url":"./post.html?BinaryTree=wyvort"},{"markdown":"[原贴](https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xoh1zg/)\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n### 题解1\n\n","time":"2021-04-05 21:23:47","title":"二叉树的最大深度","url":"./post.html?BinaryTree=wlmaou"},{"markdown":"给你一个二叉树, 按照 **层序遍历** 返回节点值.\n\n## 层序遍历\n\n从根节点到树枝, 从左至右, 即一层一层从左至右遍历二叉树.\n\n### 题解1\n\n很容易想到广度优先搜索.\n\n","time":"2021-04-05 20:51:46","title":"二叉树的层序遍历","url":"./post.html?BinaryTree=awearr"},{"markdown":"给你二叉树的根节点 `root` ，返回它节点值的 **后序** 遍历。\n\n## 关于二叉树的后序遍历\n\n后序遍历是先记录左子树, 再记录右子树, 最后记录根节点, 对于子树也执行相应操作.\n\n### 题解1\n  \n隐式使用栈来遍历, 也就是递归.\n\n","time":"2021-04-05 20:39:07","title":"二叉树的后序遍历","url":"./post.html?BinaryTree=nascrr"}]