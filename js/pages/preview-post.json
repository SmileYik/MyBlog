[{"markdown":"[原贴](https://leetcode-cn.com/leetbook/read/linked-list/jbex5/)\n\n给定一个链表，判断链表中是否有环。\n\n如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。注意：`pos` 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n\n如果链表中存在环，则返回 `true` 。 否则，返回 `false` 。\n\n\n### 题解1 - HashSet\n","time":"2021-04-09 14:32:17","title":"环形链表","url":"./post.html?LinkedList=dwlidn"},{"markdown":"[原贴](https://leetcode-cn.com/leetbook/read/linked-list/jy291/)\n\n设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：`val` 和 `next`。val 是当前节点的值，`next` 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点都是 `0-index` 的。\n\n在链表类中实现这些功能：\n+ `get(index)`：获取链表中第 index 个节点的值。如果索引无效，则返回-1。\n+ `addAtHead(val)`：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。\n+ `addAtTail(val)`：将值为 val 的节点追加到链表的最后一个元素。\n+ `addAtIndex(index,val)`：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。\n+ `deleteAtIndex(index)`：如果索引 index 有效，则删除链表中的第 index 个节点。\n","time":"2021-04-09 13:39:42","title":"设计链表","url":"./post.html?LinkedList=rlzord"},{"markdown":"[原贴](https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xopaih/)\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n\n[百度百科](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin) 中最近公共祖先的定义为：“对于有根树 `T` 的两个节点 `p`、`q`，最近公共祖先表示为一个节点 `x`，满足 `x` 是 `p、q` 的祖先且 `x` 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n### 题解1\n\n搜索root节点下的子树, 如果子树中, p, q节点都存在, 则代表root是它的祖先.\n\n","time":"2021-04-09 12:48:27","title":"二叉树的最近公共祖先","url":"./post.html?BinaryTree=xphnsv"},{"markdown":"与之前发的 **填充每个节点的下一个右侧节点指针** 题目类似, 但是这次传入的参数并不是 ~~**完全二叉树**~~\n\n### 题解1\n\n与 **填充每个节点的下一个右侧节点指针** 的题解1相同, 使用 **广度优先搜索** 来解决.\n\n代码与其一致.\n\n```java\n/*\n","time":"2021-04-09 12:40:27","title":"填充每个节点的下一个右侧节点指针 II","url":"./post.html?BinaryTree=yuqjuu"},{"markdown":"[原贴](https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xoo0ts/)\n\n给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\n\n    struct Node {\n      int val;\n      Node *left;\n      Node *right;\n      Node *next;\n    }\n","time":"2021-04-09 12:35:59","title":"填充每个节点的下一个右侧节点指针","url":"./post.html?BinaryTree=fyfvnf"}]