[{"markdown":"[原贴](https://leetcode-cn.com/leetbook/read/queue-stack/gle1r/)\n\n有 `N` 个房间，开始时你位于 `0` 号房间。每个房间有不同的号码：`0，1，2，...，N-1`，并且房间里可能有一些钥匙能使你进入下一个房间。\n\n在形式上，对于每个房间 `i` 都有一个钥匙列表 `rooms[i]`，每个钥匙 `rooms[i][j]` 由 `[0,1，...，N-1]` 中的一个整数表示，其中 `N = rooms.length`。 钥匙 `rooms[i][j] = v` 可以打开编号为 `v` 的房间。\n\n最初，除 `0` 号房间外的其余所有房间都被锁住。\n\n你可以自由地在房间之间来回走动。\n\n","time":"2021-04-04 19:03:21","title":"钥匙和房间","url":"./post.html?QueueAndStack=sdkzxe"},{"markdown":"[原贴](https://leetcode-cn.com/leetbook/read/queue-stack/g7pyt/)\n\n给定一个由 `0` 和 `1` 组成的矩阵，找出每个元素到最近的 `0` 的距离。\n\n两个相邻元素间的距离为 `1` 。\n\n示例 1：\n\n    输入：\n    [[0,0,0],\n","time":"2021-04-04 18:48:29","title":"01 矩阵","url":"./post.html?QueueAndStack=pdrdqq"},{"markdown":"[原贴](https://leetcode-cn.com/leetbook/read/queue-stack/g02cj/)\n\n有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 `0` 到 `65535` 之间。\n\n给你一个坐标 `(sr, sc)` 表示图像渲染开始的像素值`（行 ，列）`和一个新的颜色值 `newColor`，让你重新上色这幅图像。\n\n为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。\n\n最后返回经过上色渲染后的图像。\n\n","time":"2021-04-04 18:07:25","title":"图像渲染","url":"./post.html?QueueAndStack=mrrsej"},{"markdown":"[原贴](https://leetcode-cn.com/leetbook/read/queue-stack/gdwjv/)\n\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。\n\n","time":"2021-04-04 17:30:39","title":"字符串解码","url":"./post.html?QueueAndStack=wtllls"},{"markdown":"[原贴](https://leetcode-cn.com/leetbook/read/queue-stack/gw7fg/)\n\n请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（`push`、`top`、`pop` 和 `empty`）。\n\n实现 MyStack 类：\n+ `void push(int x)` 将元素 x 压入栈顶。\n+ `int pop()` 移除并返回栈顶元素。\n+ `int top()` 返回栈顶元素。\n+ `boolean empty()` 如果栈是空的，返回 true ；否则，返回 false 。\n \n","time":"2021-04-04 16:38:08","title":"用队列实现栈","url":"./post.html?QueueAndStack=mlhese"}]