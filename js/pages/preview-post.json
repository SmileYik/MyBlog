[{"markdown":"提供某个二叉树的中序排序与后序排序, 依照其重新构建出这个二叉树.\n\n\n## 思路\n\n中序遍历二叉树是先遍历左子树, 再记录根节点, 最后遍历右子树, 即 **左-根-右**\n\n后序遍历二叉树是先遍历左子树, 再遍历右子树, 最后记录根节点, 即 **左-右-根**\n\n这样看来, 给予的2个数组首个必是左树叶, 后序遍历的末尾一个必是根节点, 而在中序排序之间, 找到了根节点, 那么根节点左边就是左子树, 右边就是右子树.\n","time":"2021-04-07 13:37:09","title":"从中序与后序遍历序列构造二叉树","url":"./post.html?BinaryTree=irvcpk"},{"markdown":"[原贴](https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xo566j/)\n\n给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` ，判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。\n\n**叶子节点** 是指没有子节点的节点。\n\n提示：\n+ 树中节点的数目在范围 `[0, 5000]` 内\n+ $-1000 <= Node.val <= 1000$\n+ $-1000 <= targetSum <= 1000$\n","time":"2021-04-05 22:40:58","title":"路径总和","url":"./post.html?BinaryTree=umvdbe"},{"markdown":"[原贴](https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xoxzgv/)\n\n给定一个二叉树, 判断他是否镜像对称的.\n\n例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。\n\n        1\n       / \\\n      2   2\n     / \\ / \\\n","time":"2021-04-05 21:59:02","title":"对称二叉树","url":"./post.html?BinaryTree=wyvort"},{"markdown":"[原贴](https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xoh1zg/)\n\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明: 叶子节点是指没有子节点的节点。\n\n### 题解1\n\n","time":"2021-04-05 21:23:47","title":"二叉树的最大深度","url":"./post.html?BinaryTree=wlmaou"},{"markdown":"给你一个二叉树, 按照 **层序遍历** 返回节点值.\n\n## 层序遍历\n\n从根节点到树枝, 从左至右, 即一层一层从左至右遍历二叉树.\n\n### 题解1\n\n很容易想到广度优先搜索.\n\n","time":"2021-04-05 20:51:46","title":"二叉树的层序遍历","url":"./post.html?BinaryTree=awearr"}]