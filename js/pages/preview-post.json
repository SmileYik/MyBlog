[{"markdown":"[原贴](https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xopaih/)\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n\n[百度百科](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin) 中最近公共祖先的定义为：“对于有根树 `T` 的两个节点 `p`、`q`，最近公共祖先表示为一个节点 `x`，满足 `x` 是 `p、q` 的祖先且 `x` 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n### 题解1\n\n搜索root节点下的子树, 如果子树中, p, q节点都存在, 则代表root是它的祖先.\n\n","time":"2021-04-09 12:48:27","title":"二叉树的最近公共祖先","url":"./post.html?BinaryTree=xphnsv"},{"markdown":"与之前发的 **填充每个节点的下一个右侧节点指针** 题目类似, 但是这次传入的参数并不是 ~~**完全二叉树**~~\n\n### 题解1\n\n与 **填充每个节点的下一个右侧节点指针** 的题解1相同, 使用 **广度优先搜索** 来解决.\n\n代码与其一致.\n\n```java\n/*\n","time":"2021-04-09 12:40:27","title":"填充每个节点的下一个右侧节点指针 II","url":"./post.html?BinaryTree=yuqjuu"},{"markdown":"[原贴](https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xoo0ts/)\n\n给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\n\n    struct Node {\n      int val;\n      Node *left;\n      Node *right;\n      Node *next;\n    }\n","time":"2021-04-09 12:35:59","title":"填充每个节点的下一个右侧节点指针","url":"./post.html?BinaryTree=fyfvnf"},{"markdown":"提供某个二叉树的前序遍历和遍历, 依照其重新构建出这个二叉树.\n\n\n## 思路\n\n前序遍历二叉树是先记录根节点, 再遍历左子树, 最后遍历右子树, 即 **根-左-右**\n\n中序遍历二叉树是先遍历左子树, 再记录根节点, 最后遍历右子树, 即 **左-根-右**\n\n这样看来, 给予的2个数组末尾个必是右树叶, 前序遍历的首个必是根节点, 而在中序遍历之间, 找到了根节点, 那么根节点左边就是左子树, 右边就是右子树.\n","time":"2021-04-07 16:27:50","title":"从前序与中序遍历序列构造二叉树","url":"./post.html?BinaryTree=kxixwe"},{"markdown":"提供某个二叉树的中序排序与后序排序, 依照其重新构建出这个二叉树.\n\n\n## 思路\n\n中序遍历二叉树是先遍历左子树, 再记录根节点, 最后遍历右子树, 即 **左-根-右**\n\n后序遍历二叉树是先遍历左子树, 再遍历右子树, 最后记录根节点, 即 **左-右-根**\n\n这样看来, 给予的2个数组首个必是左树叶, 后序遍历的末尾一个必是根节点, 而在中序排序之间, 找到了根节点, 那么根节点左边就是左子树, 右边就是右子树.\n","time":"2021-04-07 13:37:09","title":"从中序与后序遍历序列构造二叉树","url":"./post.html?BinaryTree=irvcpk"}]