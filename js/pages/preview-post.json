[{"markdown":"[原贴](https://leetcode-cn.com/leetbook/read/linked-list/jy291/)\n\n设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：`val` 和 `next`。val 是当前节点的值，`next` 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点都是 `0-index` 的。\n\n在链表类中实现这些功能：\n+ `get(index)`：获取链表中第 index 个节点的值。如果索引无效，则返回-1。\n+ `addAtHead(val)`：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。\n+ `addAtTail(val)`：将值为 val 的节点追加到链表的最后一个元素。\n+ `addAtIndex(index,val)`：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。\n+ `deleteAtIndex(index)`：如果索引 index 有效，则删除链表中的第 index 个节点。\n","time":"2021-04-09 13:39:42","title":"设计链表","url":"./post.html?LinkedList=rlzord"},{"markdown":"[原贴](https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xopaih/)\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n\n[百度百科](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin) 中最近公共祖先的定义为：“对于有根树 `T` 的两个节点 `p`、`q`，最近公共祖先表示为一个节点 `x`，满足 `x` 是 `p、q` 的祖先且 `x` 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n### 题解1\n\n搜索root节点下的子树, 如果子树中, p, q节点都存在, 则代表root是它的祖先.\n\n","time":"2021-04-09 12:48:27","title":"二叉树的最近公共祖先","url":"./post.html?BinaryTree=xphnsv"},{"markdown":"与之前发的 **填充每个节点的下一个右侧节点指针** 题目类似, 但是这次传入的参数并不是 ~~**完全二叉树**~~\n\n### 题解1\n\n与 **填充每个节点的下一个右侧节点指针** 的题解1相同, 使用 **广度优先搜索** 来解决.\n\n代码与其一致.\n\n```java\n/*\n","time":"2021-04-09 12:40:27","title":"填充每个节点的下一个右侧节点指针 II","url":"./post.html?BinaryTree=yuqjuu"},{"markdown":"[原贴](https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xoo0ts/)\n\n给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\n\n    struct Node {\n      int val;\n      Node *left;\n      Node *right;\n      Node *next;\n    }\n","time":"2021-04-09 12:35:59","title":"填充每个节点的下一个右侧节点指针","url":"./post.html?BinaryTree=fyfvnf"},{"markdown":"提供某个二叉树的前序遍历和遍历, 依照其重新构建出这个二叉树.\n\n\n## 思路\n\n前序遍历二叉树是先记录根节点, 再遍历左子树, 最后遍历右子树, 即 **根-左-右**\n\n中序遍历二叉树是先遍历左子树, 再记录根节点, 最后遍历右子树, 即 **左-根-右**\n\n这样看来, 给予的2个数组末尾个必是右树叶, 前序遍历的首个必是根节点, 而在中序遍历之间, 找到了根节点, 那么根节点左边就是左子树, 右边就是右子树.\n","time":"2021-04-07 16:27:50","title":"从前序与中序遍历序列构造二叉树","url":"./post.html?BinaryTree=kxixwe"}]