##### 为 FixedCapacityStackOfString 添加一个方法 isFull().

```java
/**
 * chap1.three.FixedCapacityStackOfString.java.

 * @author miSkYle
 */

package chap1.three;

/**
 * FixedCapacityStackOfStrings.

 * @author miSkYle
 *
 */
public class FixedCapacityStackOfStrings {
  private String[] container;
  private int top = -1;

  /**
   * 初始化栈的空间.

   * @param cap 栈的空间大小.
   */
  public FixedCapacityStackOfStrings(int cap) {
    container = new String[cap];
  }

  /**
   * 压入一个元素到栈中.

   * @param item 要压入栈的元素.
   * @throws ArrayIndexOutOfBoundsException 如果这个栈已经满了则抛出.
   */
  public void push(String item) {
    if (isFull()) {
      throw new ArrayIndexOutOfBoundsException("This stack is full!");
    }
    container[++top] = item;
  }

  /**
   * 弹出栈顶元素, 并将其从栈中删除.

   * @return 返回栈顶的元素.
   * @throws ArrayIndexOutOfBoundsException 如果这个栈为空
   */
  public String pop() {
    if (isEmpty()) {
      throw new ArrayIndexOutOfBoundsException("This stack is empty!");
    }
    String item = container[top];
    container[top--] = null;
    return item;
  }

  /**
   * 返回这个栈是否为空.

   * @return 如果栈为空则返回true.
   */
  public boolean isEmpty() {
    return top == -1;
  }

  /**
   * 返回这个栈中元素的个数.

   * @return 栈中含有的元素个数.
   */
  public int size() {
    return top + 1;
  }

  /**
   * 返回这个栈是否已经满了.

   * @return 如果栈已经满了则返回true.
   */
  public boolean isFull() {
    return top == container.length - 1;
  }
}

```

验证代码如下:

```java
/**
 * chap1.three.FixedCapacityStackOfStringsTest.java.

 * @author miSkYle
 */

package chap1.three;

import java.util.Scanner;

/**
 * description.

 * @author miSkYle
 *
 */
public class FixedCapacityStackOfStringsTest {
  public static void main(String[] args) {
    System.out.println("Enter exit to stop.");
    Scanner in = new Scanner(System.in);
    FixedCapacityStackOfStrings stack = new FixedCapacityStackOfStrings(10);
    while (true) {
      String word = in.next();
      if (word.equalsIgnoreCase("exit")) {
        break;
      } else if (word.equals("-")) {
        String pop = stack.pop();
        System.out.println("Pop  Item: " + pop);
      } else {
        stack.push(word);
        System.out.println("Push Item: " + word);
      }
    }
    in.close();

    FixedCapacityStackOfStrings temp = new FixedCapacityStackOfStrings(10);
    while (!stack.isEmpty()) {
      temp.push(stack.pop());
    }
    while (!temp.isEmpty()) {
      System.out.print(temp.pop() + " ");
    }
    System.out.println();
  }
}

```

运行验证代码, 输入p83页所示验证内容:

```
to be or not to - be - - that - - - is exit
```

得到以下响应:

```
Enter exit to stop.
to be or not to - be - - that - - - is exit
Push Item: to
Push Item: be
Push Item: or
Push Item: not
Push Item: to
Pop  Item: to
Push Item: be
Pop  Item: be
Pop  Item: not
Push Item: that
Pop  Item: that
Pop  Item: or
Pop  Item: be
Push Item: is
to is
```

##### 给定以下内容, java Stack 的输出是什么?

> `it was - the best - of times - - - it was - the - -`

`was best times of the was the is`

##### 假设有个混合入栈出栈操作, 入栈操作会将整数0~9按顺序压入栈, 出栈操作会打印返回值, 下面哪种序列是不可能产生的?

> * a. 4 3 2 1 0 9 8 7 6 5
> * b. 4 6 8 7 5 3 2 9 0 1
> * c. 2 5 6 7 4 8 9 3 1 0
> * d. 4 3 2 1 0 5 6 7 8 9
> * e. 1 2 3 4 5 6 9 8 7 0
> * f. 0 4 6 5 3 8 1 7 2 9
> * g. 1 4 7 9 8 6 5 3 0 2
> * h. 2 1 4 3 6 5 8 7 9 0

假设0~9数字是压入栈, - 为出栈. 则有以下内容:

* a. 0 1 2 3 4 - - - - - 5 6 7 8 9 - - - - -
* b. 就末尾0与1而言, 出栈的话应该是先1后0
* c. 0 1 2 - 3 4 5 - 6 - 7 - - 8 - 9 - - - -
* d. 0 1 2 3 4 - - - - - 5 - 6 - 7 - 8 - 9 -
* e. 0 1 - 2 - 3 - 4 - 5 - 6 - 7 8 9 - - - -
* f. 8后面应该紧贴着7
* g. 0 2 应该为 2 0
* h. 0 1 2 - - 3 4 - - 5 6 - - 7 8 - - 9 - -

综上, b, f, g的序列是不可能产生的.

##### 用 Stack 编写一个用例 Parentheses, 判断字符串括号是否匹配且完整, 匹配则返回true, 反之为false.

``` java
/**
 * chap1.three.Parentheses.java.

 * @author miSkYle
 */

package chap1.three;

import java.util.Scanner;
import java.util.Stack;

/**
 * description.

 * @author miSkYle
 *
 */
public class Parentheses {
  public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    System.out.println("Enter exit to stop.");
    while (true) {
      String str = in.next();
      if (str.equals("exit")) {
        break;
      }
      System.out.println(check(str));
    }
    in.close();
  }

  private static boolean check(String str) {
    Stack<Character> stack = new Stack<>();
    for (char c : str.toCharArray()) {
      if (c == ')') {
        if (stack.isEmpty() || stack.pop() != '(') {
          return false;
        }
      } else if (c == '}') {
        if (stack.isEmpty() || stack.pop() != '{') {
          return false;
        }
      } else if (c == ']') {
        if (stack.isEmpty() || stack.pop() != '[') {
          return false;
        }
      } else if (c == '(' || c == '[' || c == '{') {
        stack.push(c);
      }
    }
    return stack.isEmpty();
  }
}
```

测试如下:

```
Enter exit to stop.
[()]{}{[()()]()}
true
[(])
false
()
true
(())
true
([{}])
true
exit
```

##### 当 N 为 50 时 下面代码会打印什么?

```java
Stack<Integer> stack = new Stack<Integer>();
while (N > 0) {
  stack.push(N % 2);
  N = N / 2;
}
for (int d : stack) StdOut.print(d);
StdOut.println();
```

不难看出, 这段代码是将 $N_{(10)}$ 转换为 $N_{(2)}$.  
所以 N 为 50 时会打印 110010.

##### 下列代码对队列 q 进行了什么操作?

```java
Stack<String> stack = new String<String>();
while (!q.isEmpty()) {
  stack.push(q.dequeue());
}
while (!stack.isEmpty()) {
  q.enqueue(stack.pop());
}
```

这段代码将队列一个个取出后存入stack中, 再有stack一个个取出放入q中.  
队列为先进先出, 而栈为后进先出, 所以队列中的元素按照顺序依次进入栈中, 栈中将后进入到最先进入的元素顺序将元素弹出, 使得 q 中元素较于原来的元素顺序进行反转.

##### 为 Stack 加入 peek 方法, 使得返回栈顶元素但是不删除它.

```java
/**
 * chap1.three.Stack.java.

 * @author miSkYle
 */

package chap1.three;

import java.util.Iterator;

/**
 * 以数组实现的栈.

 * @author miSkYle
 *
 */
public class Stack<Item> implements Iterable<Item>{
  private Item[] items;
  int top = -1;

  @SuppressWarnings("unchecked")
  public Stack() {
    items = (Item[]) new Object[16];
  }

  @SuppressWarnings("unchecked")
  public Stack(int cap) {
    items = (Item[]) new Object[cap];
  }

  /**
   * 压入一个元素到栈中.

   * @param item 要压入栈的元素.
   * @throws ArrayIndexOutOfBoundsException 如果这个栈已经满了则抛出.
   */
  public void push(Item item) {
    // 如果数组满了, 则加倍扩大数组容量.
    if (isFull()) {
      resize(items.length * 2);
    }
    items[++top] = item;
  }

  /**
   * 弹出栈顶元素, 并将其从栈中删除.

   * @return 返回栈顶的元素.
   * @throws ArrayIndexOutOfBoundsException 如果这个栈为空
   */
  public Item pop() {
    if (isEmpty()) {
      throw new ArrayIndexOutOfBoundsException("This stack is empty!");
    }
    Item item = items[top];
    items[top--] = null;
    // 如果数组中存的元素小于当前允许存入最大的元素数量的一半, 则缩小数组.
    if (top + 1 < items.length / 4) {
      resize(items.length / 2);
    }
    return item;
  }

  /**
   * 返回栈顶的元素.

   * @return 在栈顶的元素.
   * @throws ArrayIndexOutOfBoundsException 如果这个栈为空
   */
  public Item peek() {
    if (isEmpty()) {
      throw new ArrayIndexOutOfBoundsException("This stack is empty!");
    }
    return items[top];
  }

  /**
   * 返回这个栈是否为空.

   * @return 如果栈为空则返回true.
   */
  public boolean isEmpty() {
    return top == -1;
  }

  /**
   * 返回这个栈中元素的个数.

   * @return 栈中含有的元素个数.
   */
  public int size() {
    return top + 1;
  }

  /**
   * 返回这个栈是否已经满了.

   * @return 如果栈已经满了则返回true.
   */
  public boolean isFull() {
    return top == items.length - 1;
  }

  private void resize(int length) {
    @SuppressWarnings("unchecked")
    Item[] temp = (Item[]) new Object[length];
    length = length < items.length ? length : items.length;
    for (int i = 0; i < length; ++i) {
      temp[i] = items[i];
    }
    items = temp;
  }

  @Override
  public Iterator<Item> iterator() {
    return new StackIterator();
  }

  private class StackIterator implements Iterator<Item> {
    private int i = top;

    @Override
    public boolean hasNext() {
      return i != -1;
    }

    @Override
    public Item next() {
      return items[i--];
    }
  }
}
```

##### 给定以下输入, 给出 DoublingStackOfStrings 的数组的内容和大小

> it was - the best - of times - - - it was - the - -

it 1.

##### 编写一段程序, 从标准输入中获取一个缺少左括号的表达式, 并输出补全括号之后的中序表达式.

> ```
输入: 1 + 2 ) * 3 - 4 ) * 5 - 6 ) ) )
输出: ( ( 1 + 2 ) * ( ( 3 - 4 ) * ( 5 - 6 ) ) )
> ```

可以先创建2个栈, 一个数字栈一个运算符栈.  
一对括号包裹着的算数表达式可以视为一个数字.  
之后就有如果遇到了符号, 则压入符号栈, 如果遇到了数字则压入数字栈, 如果遇到了右括号则从符号栈取出一个符号, 数字栈取出两个数字组成一个括号包裹着的算数表达式然后压入数字栈中.

```java
/**
 * chap1.three.ExNine.java.

 * @author miSkYle
 */

package chap1.three;

import java.util.Scanner;

/**
 * description.

 * @author miSkYle
 *
 */
public class ExNine {
  public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    Stack<String> numbers = new Stack<>();
    Stack<String> operators = new Stack<>();
    while (in.hasNext()) {
      String str = in.next();
      if (str.equals("+") ||
          str.equals("-") ||
          str.equals("*") ||
          str.equals("/")) {
        operators.push(str);
      } else if (str.equals(")")) {
        StringBuilder sb = new StringBuilder();
        sb.insert(0, str);
        sb.insert(0, numbers.pop());
        sb.insert(0, operators.pop());
        sb.insert(0, numbers.pop());
        sb.insert(0, "(");
        numbers.push(sb.toString());
      } else {
        numbers.push(str);
      }
    }
    in.close();
    StringBuilder sb = new StringBuilder(numbers.pop());
    for (int i = 1; i < sb.length(); i += 2) {
      sb.insert(i, " ");
    }
    System.out.println(sb);
  }
}
```

##### 编写一个过滤器 InfixToPostfix, 将算数表达式由中序表达式转为后序表达式.

以下代码不能处理负数以及带有小数点的数.

```java
/**
 * chap1.three.InfixToPostfix.java.

 * @author miSkYle
 */

package chap1.three;

/**
 * 中缀表达式转后缀表达式.

 * @author miSkYle
 *
 */
public class InfixToPostfix {
  /**
   * 中缀表达式转后缀表达式.

   * @param infix 中缀表达式
   * @return      后缀表达式
   */
  public static String infixToPostfix(String infix) {
    Stack<String> numbers = new Stack<>();
    Stack<String> operators = new Stack<>();
    int numbersIndex = -1;
    for (int i = 0; i < infix.length(); ++i) {
      char opt = infix.charAt(i);
      if (opt == '+' || opt == '-') {
        calculatePlusDev(numbers, operators);
        calculateAddSub(numbers, operators);
        operators.push(String.valueOf(opt));
      } else if (opt == '*' || opt == '/') {
        calculatePlusDev(numbers, operators);
        operators.push(String.valueOf(opt));
      } else if (opt == '(') {
        operators.push(String.valueOf(opt));
      } else if (opt == ')') {
        StringBuilder sb = new StringBuilder();
        int size = 0;
        while (!operators.peek().equals("(")) {
          sb.append(" " + operators.pop());
          ++size;
        }
        operators.pop();
        while (size >= 0) {
          sb.insert(0, " " + numbers.pop());
          --size;
        }
        numbers.push(sb.substring(1));
      } else {
        if (numbersIndex == -1) {
          numbersIndex = i;
          if (i + 1 == infix.length()) {
            numbers.push(infix.substring(i));
            numbersIndex = -1;
          } else if (infix.charAt(i + 1) < '0'
              || infix.charAt(i + 1) > '9') {
            numbers.push(infix.substring(i, i + 1));
            numbersIndex = -1;
          }
        } else if (i + 1 == infix.length()) {
          numbers.push(infix.substring(numbersIndex, i + 1));
          numbersIndex = -1;
        } else if (infix.charAt(i + 1) < '0'
            || infix.charAt(i + 1) > '9') {
          numbers.push(infix.substring(numbersIndex, i + 1));
          numbersIndex = -1;
        }
      }
    }
    calculatePlusDev(numbers, operators);
    calculateAddSub(numbers, operators);
    return numbers.pop();
  }

  /**
   * 计算乘除.

   * @param numbers     数字栈
   * @param operators   运算符栈
   */
  private static void calculatePlusDev(
      Stack<String> numbers, Stack<String> operators) {
    String num;
    while (!operators.isEmpty() &&
        (operators.peek().equals("*") ||
        operators.peek().equals("/"))) {
        num = numbers.pop();
        numbers.push(
            String.format("%s %s %s",
                numbers.pop(), num, operators.pop()));
    }
  }

  /**
   * 计算加减.

   * @param numbers     数字栈
   * @param operators   运算符栈
   */
  private static void calculateAddSub(
      Stack<String> numbers, Stack<String> operators) {
    String num;
    while (!operators.isEmpty() &&
        (operators.peek().equals("+") ||
        operators.peek().equals("-"))) {
        num = numbers.pop();
        numbers.push(
            String.format("%s %s %s",
                numbers.pop(), num, operators.pop()));
    }
  }
}
```

##### 编写一段程序 EvaluatePostfix, 从标准输入中得到一个后序表达式, 求值并打印结果.

这里省略了输入后缀表达式再计算, 而是直接输入中缀表达式,
然后通过上一道题目所写的中缀表达式转后缀表达式程序得出的后序表达式进行计算.  
后缀表达式的计算如下, 假设有如下后缀表达式:  
`a b + c - d * e /`  
那么计算先是读取前面的非符号位, 遇到符号位后, 弹出栈顶两位元素进行计算.  
`(a+b) c - d * e /`  
`((a+b)-c) d * e /`  
`(((a+b)-c)*d) e /`  
`((((a+b)-c)*d)/e)`  

```java
/**
 * chap1.three.EvaluatePostfix.java.

 * @author miSkYle
 */

package chap1.three;

import java.util.Scanner;

/**
 * 编写一段程序 EvaluatePostfix, 从标准输入中得到一个后序表达式, 求值并打印结果.

 * @author miSkYle
 *
 */
public class EvaluatePostfix {

  public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    while (in.hasNext()) {
      String str = in.next();
      if (str.equals("exit")) {
        break;
      }
      String postfix = InfixToPostfix.infixToPostfix(str);
      double answer  = evaluatePostfix(postfix);
      System.out.println(str + " = " + postfix + " = " + answer);
    }
    in.close();
  }

  /**
   * 对后序表达式进行求值.

   * @param postfix 后缀表达式.
   * @return        后缀表达式所计算出的值
   */
  public static double evaluatePostfix(String postfix) {
    Stack<Double> numbers = new Stack<>();
    for (String str : postfix.split(" ")) {
      if (str.equals("+")) {
        double num = numbers.pop();
        numbers.push(numbers.pop() + num);
      } else if (str.equals("-")) {
        double num = numbers.pop();
        numbers.push(numbers.pop() - num);
      } else if (str.equals("*")) {
        double num = numbers.pop();
        numbers.push(numbers.pop() * num);
      } else if (str.equals("/")) {
        double num = numbers.pop();
        numbers.push(numbers.pop() / num);
      } else {
        numbers.push(Double.parseDouble(str));
      }
    }
    return numbers.pop();
  }
}
```

##### 编写一个可迭代的 Stack 用例, 它含有一个静态的 copy() 方法, 用来返回栈的副本

在之前写的 Stack.java 中进行修改即可.

```java
/**
 * chap1.three.Stack.java.

 * @author miSkYle
 */

package chap1.three;

import java.util.Iterator;

/**
 * 以数组实现的栈.

 * @author miSkYle
 *
 */
public class Stack<Item> implements Iterable<Item>{
  private Item[] items;
  private int top = -1;

  @SuppressWarnings("unchecked")
  public Stack() {
    items = (Item[]) new Object[16];
  }

  @SuppressWarnings("unchecked")
  public Stack(int cap) {
    items = (Item[]) new Object[cap];
  }

  /**
   * 压入一个元素到栈中.

   * @param item 要压入栈的元素.
   * @throws ArrayIndexOutOfBoundsException 如果这个栈已经满了则抛出.
   */
  public void push(Item item) {
    // 如果数组满了, 则加倍扩大数组容量.
    if (isFull()) {
      resize(items.length * 2);
    }
    items[++top] = item;
  }

  /**
   * 弹出栈顶元素, 并将其从栈中删除.

   * @return 返回栈顶的元素.
   * @throws ArrayIndexOutOfBoundsException 如果这个栈为空
   */
  public Item pop() {
    if (isEmpty()) {
      throw new ArrayIndexOutOfBoundsException("This stack is empty!");
    }
    Item item = items[top];
    items[top--] = null;
    // 如果数组中存的元素小于当前允许存入最大的元素数量的一半, 则缩小数组.
    if (top + 1 < items.length / 4) {
      resize(items.length / 2);
    }
    return item;
  }

  /**
   * 返回栈顶的元素.

   * @return 在栈顶的元素.
   * @throws ArrayIndexOutOfBoundsException 如果这个栈为空
   */
  public Item peek() {
    if (isEmpty()) {
      throw new ArrayIndexOutOfBoundsException("This stack is empty!");
    }
    return items[top];
  }

  /**
   * 返回这个栈是否为空.

   * @return 如果栈为空则返回true.
   */
  public boolean isEmpty() {
    return top == -1;
  }

  /**
   * 返回这个栈中元素的个数.

   * @return 栈中含有的元素个数.
   */
  public int size() {
    return top + 1;
  }

  /**
   * 返回这个栈是否已经满了.

   * @return 如果栈已经满了则返回true.
   */
  public boolean isFull() {
    return top == items.length - 1;
  }

  private void resize(int length) {
    @SuppressWarnings("unchecked")
    Item[] temp = (Item[]) new Object[length];
    length = length < items.length ? length : items.length;
    for (int i = 0; i < length; ++i) {
      temp[i] = items[i];
    }
    items = temp;
  }

  /**
   * 复制一个栈, 返回包含相同元素的新栈.

   * @param <Item>
   * @param old 需要复制的栈.
   * @return    包含原有栈中相同元素的新栈.
   */
  public static <Item> Stack<Item> copy(Stack<Item> old) {
    Stack<Item> newOne = new Stack<>(old.items.length);
    for (int i = 0; i < newOne.items.length; ++i) {
      newOne.items[i] = old.items[i];
    }
    newOne.top = old.top;
    return newOne;
  }

  @Override
  public Iterator<Item> iterator() {
    return new StackIterator();
  }

  private class StackIterator implements Iterator<Item> {
    private int i = top;

    @Override
    public boolean hasNext() {
      return i != -1;
    }

    @Override
    public Item next() {
      return items[i--];
    }
  }
}
```
























































































.
