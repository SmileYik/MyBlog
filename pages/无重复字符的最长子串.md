## 无重复字符的最长子串  
  
    
**时间：2021.3.12**  
  
### 题目  
  
  
给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。  
  
#### 示例  
  
    输入: s = "abcabcbb"
    输出: 3 
    解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

	输入: s = "bbbbb"
	输出: 1
	解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
	
	输入: s = "pwwkew"
	输出: 3
	解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
		 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

	输入: s = ""
	输出: 0

  
### 个人题解  
  
```
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int max = 0;
        String str = ""; //记录未重复字符串。
        for (char temp : s.toCharArray()) {
            if (str.contains(temp + "")) { //判断str字符串中是否包含当前字符。
				//str包含当前字符。
				//将str在当前字符处分割。
				//当得出的字符串数组长度为0时， 代表原来str字符串中为空字符或者都为temp这个字符。
				//当得出的字符串数组长度为1时， 代表原来str字符串中， temp这个字符在字符串末尾。
				//故当数组为长度小于2（不包含）时，str应该为空串加上当前的字符temp。
				//当得出的字符串数组长度大于等于2时，数组中最后一个字符串代表此次含有不同字符的字符串， 同时得加上当前字符。
				//所以这时候str应该为字符串数组中最后一个字符串并且加上当前字符temp的字符串。
                String[] strs = str.split(temp + ""); 
                if (strs.length < 2) {
                    str = temp + "";
                } else {
                    str = strs[strs.length - 1] + temp;
                }
                
            } else {
				//str字符串中不包含当前temp字符.
				//则str直接在末端加上temp字符。
                str += temp;
                if (str.length() > max) {
					//判断当前str字符串的长度是否超过了最大长度。
					//若超过了最大长度则更新max的值。
                    max = str.length();
                }
            }
        }
        return max;
    }
}
```  
  
