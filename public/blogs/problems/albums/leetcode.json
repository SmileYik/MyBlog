{
    "author": "Smile Yik",
    "id": "leetcode",
    "items": [
        {
            "author": "Smile Yik",
            "id": "lc-bt-0",
            "items": [
                {
                    "author": "Smile Yik",
                    "id": "lc-bt-1",
                    "items": [
                    ],
                    "markdown": "LeetCode/BinaryTree/二叉树的中序遍历.md",
                    "modifyTime": 1647100852124,
                    "postTime": 1647100852123,
                    "prev": "给你二叉树的根节点 `root` ，返回它节点值的 **中序** 遍历。## 关于二叉树的中序遍历中序遍历是先记录左子树, 再记录根节点, 最后记录右子树, 对于子树也执行相应操作.",
                    "tag": "二叉树,,",
                    "title": "二叉树的中序遍历"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-bt-2",
                    "items": [
                    ],
                    "markdown": "LeetCode/BinaryTree/二叉树的前序遍历.md",
                    "modifyTime": 1647100863776,
                    "postTime": 1647100863776,
                    "prev": "给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。## 关于二叉树的前序遍历前序遍历是先遍历根节点, 再记录左子树, 最后记录后子树. 对于子树也是进行相同操作.",
                    "tag": "二叉树,,",
                    "title": "二叉树的前序遍历"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-bt-3",
                    "items": [
                    ],
                    "markdown": "LeetCode/BinaryTree/二叉树的后序遍历.md",
                    "modifyTime": 1647100872173,
                    "postTime": 1647100872173,
                    "prev": "给你二叉树的根节点 `root` ，返回它节点值的 **后序** 遍历。## 关于二叉树的后序遍历后序遍历是先记录左子树, 再记录右子树, 最后记录根节点, 对于子树也执行相应操作.",
                    "tag": "二叉树,,",
                    "title": "二叉树的后序遍历"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-bt-4",
                    "items": [
                    ],
                    "markdown": "LeetCode/BinaryTree/二叉树的层序遍历.md",
                    "modifyTime": 1647100889943,
                    "postTime": 1647100889943,
                    "prev": "给你一个二叉树, 按照 **层序遍历** 返回节点值.## 层序遍历从根节点到树枝, 从左至右, 即一层一层从左至右遍历二叉树.",
                    "tag": "队列,二叉树,,",
                    "title": "二叉树的层序遍历"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-bt-5",
                    "items": [
                    ],
                    "markdown": "LeetCode/BinaryTree/二叉树的最大深度.md",
                    "modifyTime": 1647100913890,
                    "postTime": 1647100913890,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xoh1zg/)给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。",
                    "tag": "栈,二叉树,,",
                    "title": "二叉树的最大深度"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-bt-6",
                    "items": [
                    ],
                    "markdown": "LeetCode/BinaryTree/二叉树的最近公共祖先.md",
                    "modifyTime": 1647100930384,
                    "postTime": 1647100930384,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xopaih/)给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。[百度百科](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin) 中最近公共祖先的定义为：“对于有根树 `T` 的两个节点 `p`、`q`，最近公共祖先表示为一个节点 `x`，满足 `x` 是 `p、q` 的祖先且 `x` 的深度尽可能大（一个节点也可以是它自己的祖先）。”",
                    "tag": "二叉树,,",
                    "title": "二叉树的最近公共祖先"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-bt-7",
                    "items": [
                    ],
                    "markdown": "LeetCode/BinaryTree/从中序与后序遍历序列构造二叉树.md",
                    "modifyTime": 1647100962052,
                    "postTime": 1647100962052,
                    "prev": "提供某个二叉树的中序遍历与后序遍历, 依照其重新构建出这个二叉树.## 思路",
                    "tag": "二叉树,,",
                    "title": "从中序遍历与后序遍历序列构造二叉树"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-bt-8",
                    "items": [
                    ],
                    "markdown": "LeetCode/BinaryTree/从前序与中序遍历序列构造二叉树.md",
                    "modifyTime": 1647100972141,
                    "postTime": 1647100972141,
                    "prev": "提供某个二叉树的前序遍历和遍历, 依照其重新构建出这个二叉树.## 思路",
                    "tag": "二叉树,,",
                    "title": "从中序遍历与前序遍历序列构造二叉树"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-bt-10",
                    "items": [
                    ],
                    "markdown": "LeetCode/BinaryTree/填充每个节点的下一个右侧节点指针.md",
                    "modifyTime": 1647101033957,
                    "postTime": 1647101033957,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xoo0ts/)给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：    struct Node {",
                    "tag": "二叉树,,",
                    "title": "填充每个节点的下一个右侧节点指针"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-bt-9",
                    "items": [
                    ],
                    "markdown": "LeetCode/BinaryTree/填充每个节点的下一个右侧节点指针 II.md",
                    "modifyTime": 1647101024866,
                    "postTime": 1647101024866,
                    "prev": "与之前发的 **填充每个节点的下一个右侧节点指针** 题目类似, 但是这次传入的参数并不是 ~~**完全二叉树**~~### 题解1与 **填充每个节点的下一个右侧节点指针** 的题解1相同, 使用 **广度优先搜索** 来解决.",
                    "tag": "二叉树,,",
                    "title": "填充每个节点的下一个右侧节点指针 II"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-bt-11",
                    "items": [
                    ],
                    "markdown": "LeetCode/BinaryTree/对称二叉树.md",
                    "modifyTime": 1647101048456,
                    "postTime": 1647101048456,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xoxzgv/)给定一个二叉树, 判断他是否镜像对称的.例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。",
                    "tag": "二叉树,,",
                    "title": "对称二叉树"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-bt-12",
                    "items": [
                    ],
                    "markdown": "LeetCode/BinaryTree/路径总和.md",
                    "modifyTime": 1647101060189,
                    "postTime": 1647101060189,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xo566j/)给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` ，判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。**叶子节点** 是指没有子节点的节点。",
                    "tag": "二叉树,,",
                    "title": "路径总和"
                }
            ],
            "markdown": "LeetCode/BinaryTree/二叉树.md",
            "modifyTime": 1647102141808,
            "postTime": 1647102141808,
            "prev": " ",
            "tag": "二叉树,,",
            "title": "二叉树题目集"
        },
        {
            "author": "Smile Yik",
            "id": "lc-linkedlist-0",
            "items": [
                {
                    "author": "Smile Yik",
                    "id": "lc-linkedlist-13",
                    "items": [
                    ],
                    "markdown": "LeetCode/LinkedList/删除链表的倒数第 N 个结点.md",
                    "modifyTime": 1647101091746,
                    "postTime": 1647101091746,
                    "prev": "给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。### 题解1先确定倒数第 n 个节点是顺序第几个节点, 然后再次遍历以删除.",
                    "tag": "链表,,",
                    "title": "删除链表的倒数第N个节点"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-linkedlist-2",
                    "items": [
                    ],
                    "markdown": "LeetCode/LinkedList/环形链表.md",
                    "modifyTime": 1647101114777,
                    "postTime": 1647101114777,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/linked-list/jbex5/)给定一个链表，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。注意：`pos` 不作为参数进行传递，仅仅是为了标识链表的实际情况。",
                    "tag": "链表,,",
                    "title": "环形链表"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-linkedlist-1",
                    "items": [
                    ],
                    "markdown": "LeetCode/LinkedList/环形链表 II.md",
                    "modifyTime": 1647101109111,
                    "postTime": 1647101109111,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/linked-list/jjhf6/)给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 `0` 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。注意，`pos` 仅仅是用于标识环的情况，并不会作为参数传递到函数中。",
                    "tag": "链表,,",
                    "title": "环形链表 II"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-linkedlist-3",
                    "items": [
                    ],
                    "markdown": "LeetCode/LinkedList/相交链表.md",
                    "modifyTime": 1647101125751,
                    "postTime": 1647101125751,
                    "prev": "编写一个程序，找到两个单链表相交的起始节点。如下面的两个链表：![linkedlist](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)",
                    "tag": "链表,,",
                    "title": "相交链表"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-linkedlist-4",
                    "items": [
                    ],
                    "markdown": "LeetCode/LinkedList/设计链表.md",
                    "modifyTime": 1647101133972,
                    "postTime": 1647101133972,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/linked-list/jy291/)设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：`val` 和 `next`。val 是当前节点的值，`next` 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点都是 `0-index` 的。在链表类中实现这些功能：",
                    "tag": "链表,,",
                    "title": "设计链表"
                }
            ],
            "markdown": "LeetCode/LinkedList/链表.md",
            "modifyTime": 1647102255078,
            "postTime": 1647102255078,
            "prev": " ",
            "tag": "链表,,",
            "title": "链表题目集"
        },
        {
            "author": "Smile Yik",
            "id": "lc-queuestack-0",
            "items": [
                {
                    "author": "Smile Yik",
                    "id": "lc-queuestack-1",
                    "items": [
                    ],
                    "markdown": "LeetCode/QueueAndStack/01 矩阵.md",
                    "modifyTime": 1647101170459,
                    "postTime": 1647101170459,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/queue-stack/g7pyt/)给定一个由 `0` 和 `1` 组成的矩阵，找出每个元素到最近的 `0` 的距离。两个相邻元素间的距离为 `1` 。",
                    "tag": "栈,队列,,",
                    "title": "01 矩阵"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-queuestack-2",
                    "items": [
                    ],
                    "markdown": "LeetCode/QueueAndStack/克隆图.md",
                    "modifyTime": 1647101189638,
                    "postTime": 1647101189638,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/queue-stack/gmcr6/)给你无向 `连通` 图中一个节点的引用，请你返回该图的 `深拷贝`（克隆）。图中的每个节点都包含它的值 `val`（`int`） 和其邻居的列表（`list[Node]`）。",
                    "tag": "栈,队列,,",
                    "title": "克 隆 图"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-queuestack-3",
                    "items": [
                    ],
                    "markdown": "LeetCode/QueueAndStack/图像渲染.md",
                    "modifyTime": 1647101197540,
                    "postTime": 1647101197540,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/queue-stack/g02cj/)有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 `0` 到 `65535` 之间。给你一个坐标 `(sr, sc)` 表示图像渲染开始的像素值`（行 ，列）`和一个新的颜色值 `newColor`，让你重新上色这幅图像。",
                    "tag": "栈,队列,,",
                    "title": "图像渲染"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-queuestack-4",
                    "items": [
                    ],
                    "markdown": "LeetCode/QueueAndStack/字符串解码.md",
                    "modifyTime": 1647101205039,
                    "postTime": 1647101205039,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/queue-stack/gdwjv/)给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。",
                    "tag": "栈,队列,,",
                    "title": "字符串解码"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-queuestack-5",
                    "items": [
                    ],
                    "markdown": "LeetCode/QueueAndStack/完全平方数.md",
                    "modifyTime": 1647101215422,
                    "postTime": 1647101215422,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/queue-stack/kfgtt/)给定正整数 `n`，找到若干个完全平方数（比如 `1, 4, 9, 16, ...`）使得它们的和等于 `n`。你需要让组成和的完全平方数的个数**最少**。给你一个整数 `n` ，返回和为 `n` 的完全平方数的 **最少数量** 。",
                    "tag": "栈,队列,,",
                    "title": "完全平方数"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-queuestack-6",
                    "items": [
                    ],
                    "markdown": "LeetCode/QueueAndStack/岛屿数量.md",
                    "modifyTime": 1647101225098,
                    "postTime": 1647101225098,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/queue-stack/kj48j/)给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。",
                    "tag": "栈,队列,,",
                    "title": "岛屿数量"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-queuestack-7",
                    "items": [
                    ],
                    "markdown": "LeetCode/QueueAndStack/打开转盘锁.md",
                    "modifyTime": 1647101236041,
                    "postTime": 1647101236041,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/queue-stack/kj48j/)你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： `'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'` 。每个拨轮可以自由旋转：例如把 `'9'` 变为  `'0'`，`'0'` 变为 `'9'` 。每次旋转都只能旋转一个拨轮的一位数字。锁的初始数字为 `'0000'` ，一个代表四个拨轮的数字的字符串。",
                    "tag": "栈,队列,,",
                    "title": "打开转盘锁"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-queuestack-8",
                    "items": [
                    ],
                    "markdown": "LeetCode/QueueAndStack/最近的请求次数.md",
                    "modifyTime": 1647101246933,
                    "postTime": 1647101246933,
                    "prev": "写一个 `RecentCounter` 类来计算特定时间范围内最近的请求。请你实现 `RecentCounter` 类：`RecentCounter()` 初始化计数器，请求数为 `0` 。",
                    "tag": "栈,队列,,",
                    "title": "最近的请求次数"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-queuestack-9",
                    "items": [
                    ],
                    "markdown": "LeetCode/QueueAndStack/有效的括号.md",
                    "modifyTime": 1647101255656,
                    "postTime": 1647101255656,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/queue-stack/g9d0h/)给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。有效字符串需满足：",
                    "tag": "栈,队列,,",
                    "title": "有效的括号"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-queuestack-10",
                    "items": [
                    ],
                    "markdown": "LeetCode/QueueAndStack/每日温度.md",
                    "modifyTime": 1647101263111,
                    "postTime": 1647101263111,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/queue-stack/genw3/)请根据每日 `气温` 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。例如，给定一个列表 `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`，你的输出应该是 `[1, 1, 4, 2, 1, 1, 0, 0]`。",
                    "tag": "栈,队列,,",
                    "title": "每日温度"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-queuestack-11",
                    "items": [
                    ],
                    "markdown": "LeetCode/QueueAndStack/用栈实现队列.md",
                    "modifyTime": 1647101273644,
                    "postTime": 1647101273644,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/queue-stack/gvtxe/)请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：实现 `MyQueue` 类：",
                    "tag": "栈,队列,,",
                    "title": "用栈实现队列"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-queuestack-12",
                    "items": [
                    ],
                    "markdown": "LeetCode/QueueAndStack/用队列实现栈.md",
                    "modifyTime": 1647101284698,
                    "postTime": 1647101284698,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/queue-stack/gw7fg/)请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（`push`、`top`、`pop` 和 `empty`）。实现 MyStack 类：",
                    "tag": "栈,队列,,",
                    "title": "用队列实现栈"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-queuestack-13",
                    "items": [
                    ],
                    "markdown": "LeetCode/QueueAndStack/目标和.md",
                    "modifyTime": 1647101300437,
                    "postTime": 1647101300437,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/queue-stack/ga4o2/)给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 `+` 和 `-`。对于数组中的任意一个整数，你都可以从 `+` 或 `-` 中选择一个符号添加在前面。返回可以使最终数组和为目标数 S 的所有添加符号的方法数。",
                    "tag": "栈,队列,,",
                    "title": "目 标 和"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-queuestack-14",
                    "items": [
                    ],
                    "markdown": "LeetCode/QueueAndStack/逆波兰表达式求值.md",
                    "modifyTime": 1647101314872,
                    "postTime": 1647101314872,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/queue-stack/gomvm/)根据 [逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437)，求表达式的值。有效的算符包括 `+`、`-`、`*`、`/` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。",
                    "tag": "栈,队列,,",
                    "title": "逆波兰表达式求值"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-queuestack-15",
                    "items": [
                    ],
                    "markdown": "LeetCode/QueueAndStack/钥匙和房间.md",
                    "modifyTime": 1647101325261,
                    "postTime": 1647101325261,
                    "prev": "[原贴](https://leetcode-cn.com/leetbook/read/queue-stack/gle1r/)有 `N` 个房间，开始时你位于 `0` 号房间。每个房间有不同的号码：`0，1，2，...，N-1`，并且房间里可能有一些钥匙能使你进入下一个房间。在形式上，对于每个房间 `i` 都有一个钥匙列表 `rooms[i]`，每个钥匙 `rooms[i][j]` 由 `[0,1，...，N-1]` 中的一个整数表示，其中 `N = rooms.length`。 钥匙 `rooms[i][j] = v` 可以打开编号为 `v` 的房间。",
                    "tag": "栈,队列,,",
                    "title": "钥匙和房间"
                }
            ],
            "markdown": "LeetCode/QueueAndStack/queueandstack.md",
            "modifyTime": 1647102343306,
            "postTime": 1647102343306,
            "prev": " ",
            "tag": "栈,队列,,",
            "title": "栈和队列题目集"
        },
        {
            "author": "Smile Yik",
            "id": "lc-string-0",
            "items": [
                {
                    "author": "Smile Yik",
                    "id": "lc-string-1",
                    "items": [
                    ],
                    "markdown": "LeetCode/String/解码方法.md",
                    "modifyTime": 1647101340784,
                    "postTime": 1647101340784,
                    "prev": "一条包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：```'A' -> 1'B' -> 2...",
                    "tag": "栈,队列,,",
                    "title": "解码方法"
                }
            ],
            "markdown": "LeetCode/String/string.md",
            "modifyTime": 1647102423165,
            "postTime": 1647102423165,
            "prev": " ",
            "tag": "字符串,,",
            "title": "字符串题目集"
        },
        {
            "author": "Smile Yik",
            "id": "lc-bit-0",
            "items": [
                {
                    "author": "Smile Yik",
                    "id": "lc-bit-1",
                    "items": [
                    ],
                    "markdown": "LeetCode/位运算/汉明距离.md",
                    "modifyTime": 1647101370481,
                    "postTime": 1647101370481,
                    "prev": "两个整数之间的**汉明距离**指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 `x` 和 `y`，计算它们之间的汉明距离。注意：",
                    "tag": "位运算,,",
                    "title": "汉明距离"
                }
            ],
            "markdown": "LeetCode/位运算/位运算.md",
            "modifyTime": 1647102484339,
            "postTime": 1647102484339,
            "prev": " ",
            "tag": "位运算,,",
            "title": "位运算题目集"
        },
        {
            "author": "Smile Yik",
            "id": "lc-alg-0",
            "items": [
                {
                    "author": "Smile Yik",
                    "id": "lc-alg-dp-0",
                    "items": [
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg-dp-1",
                            "items": [
                            ],
                            "markdown": "LeetCode/AlgorithmsBookI/dp/把数字翻译成字符串.md",
                            "modifyTime": 1647101411671,
                            "postTime": 1647101411671,
                            "prev": "[原贴](https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/99wd55/)给定一个数字，我们按照如下规则把它翻译为字符串：`0` 翻译成 `“a”` ，`1` 翻译成 `“b”`，……，`11` 翻译成 `“l”`，……，`25` 翻译成 `“z”`。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。",
                            "tag": "动态规划,,",
                            "title": "把数字翻译成字符串"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg-dp-2",
                            "items": [
                            ],
                            "markdown": "LeetCode/AlgorithmsBookI/dp/斐波那契数列.md",
                            "modifyTime": 1647101439437,
                            "postTime": 1647101439437,
                            "prev": "[原贴](https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/50fxu1/)写一个函数，输入 `n` ，求斐波那契（Fibonacci）数列的第 `n` 项（即 `F(N)`）。斐波那契数列的定义如下：```F(0) = 0,   F(1) = 1",
                            "tag": "动态规划,,",
                            "title": "斐波那切数列"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg-dp-3",
                            "items": [
                            ],
                            "markdown": "LeetCode/AlgorithmsBookI/dp/礼物的最大价值.md",
                            "modifyTime": 1647101449486,
                            "postTime": 1647101449486,
                            "prev": "[原贴](https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/5vokvr/)在一个 `m * n` 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，**并每次向右或者向下移动一格、直到到达棋盘的右下角**。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？示例1: ",
                            "tag": "动态规划,,",
                            "title": "礼物的最大价值"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg-dp-4",
                            "items": [
                            ],
                            "markdown": "LeetCode/AlgorithmsBookI/dp/连续子数组的最大和.md",
                            "modifyTime": 1647101464141,
                            "postTime": 1647101464141,
                            "prev": "输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。### 解法1用分治算法来解决.",
                            "tag": "动态规划,,",
                            "title": "连续数组的最大和"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg-dp-5",
                            "items": [
                            ],
                            "markdown": "LeetCode/AlgorithmsBookI/dp/青蛙跳台阶问题.md",
                            "modifyTime": 1647101475330,
                            "postTime": 1647101475330,
                            "prev": "[原贴](https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/57hyl5/)一只青蛙一次可以跳上`1`级台阶，也可以跳上`2`级台阶。求该青蛙跳上一个 `n` 级的台阶总共有多少种跳法。答案需要取模 `1e9+7（1000000007）`，如计算初始结果为：`1000000008`，请返回 `1`。",
                            "tag": "动态规划,,",
                            "title": "青蛙跳台阶问题"
                        }
                    ],
                    "markdown": "LeetCode/AlgorithmsBookI/dp/dp.md",
                    "modifyTime": 1647102836762,
                    "postTime": 1647102836762,
                    "prev": " ",
                    "tag": ",",
                    "title": "动态规划题目集"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-alg-merge-0",
                    "items": [
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg-merge-1",
                            "items": [
                            ],
                            "markdown": "LeetCode/AlgorithmsBookI/merge/数值的整数次方.md",
                            "modifyTime": 1647101506138,
                            "postTime": 1647101506138,
                            "prev": "实现Math库中的`pow(x, n)` 函数, 即计算 `x` 的 `n` 次幂函数（即，$x^{n}$）。不得使用库函数，同时不需要考虑大数问题。### 题解1需要注意, 如果一个一个减过去, 那么可能会超时.",
                            "tag": "动态规划,,",
                            "title": "数值的整数次方"
                        }
                    ],
                    "markdown": "LeetCode/AlgorithmsBookI/merge/merge.md",
                    "modifyTime": 1647102848553,
                    "postTime": 1647102848553,
                    "prev": " ",
                    "tag": ",",
                    "title": "分治算法题目集"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-alg-search-0",
                    "items": [
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg-search-1",
                            "items": [
                            ],
                            "markdown": "LeetCode/AlgorithmsBookI/search/矩阵中的路径.md",
                            "modifyTime": 1647101528814,
                            "postTime": 1647101528814,
                            "prev": "[原帖](https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/58wowd/)给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。",
                            "tag": ",",
                            "title": "矩阵中的路径"
                        }
                    ],
                    "markdown": "LeetCode/AlgorithmsBookI/search/search.md",
                    "modifyTime": 1647102869473,
                    "postTime": 1647102869473,
                    "prev": " ",
                    "tag": ",",
                    "title": "搜索算法题目集"
                }
            ],
            "markdown": "LeetCode/AlgorithmsBookI/alg.md",
            "modifyTime": 1647102646246,
            "postTime": 1647102646246,
            "prev": " ",
            "tag": ",",
            "title": "算法书题目集"
        },
        {
            "author": "Smile Yik",
            "id": "lc-alg1-0",
            "items": [
                {
                    "author": "Smile Yik",
                    "id": "lc-alg1-string-0",
                    "items": [
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-string-1",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/字符串/反转字符串.md",
                            "modifyTime": 1647101574138,
                            "postTime": 1647101574138,
                            "prev": "# [反转字符串](https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnhbqj/)    ## 题目  编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 ```char[] ```的形式给出。",
                            "tag": "字符串,,",
                            "title": "反转字符串"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-string-2",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/字符串/字符串中的第一个唯一字符.md",
                            "modifyTime": 1647101589968,
                            "postTime": 1647101589968,
                            "prev": "# 字符串中的第一个唯一字符  给定一个字符串, 找到他的第一个不重复的字符, 并返回它的索引, 若不存在则返回`-1`### 题解1",
                            "tag": "字符串,,",
                            "title": "字符串中的第一个唯一字符"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-string-3",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/字符串/字符串转换整数.md",
                            "modifyTime": 1647101601920,
                            "postTime": 1647101601920,
                            "prev": "# [字符串转换整数 (atoi)](https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnoilh/)请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 `32` 位有符号整数（类似 C/C++ 中的 `atoi` 函数）。函数 `myAtoi(string s)` 的算法如下：",
                            "tag": "字符串,,",
                            "title": "字符串转换整数"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-string-4",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/字符串/实现 strStr().md",
                            "modifyTime": 1647101616270,
                            "postTime": 1647101616270,
                            "prev": "[原贴](https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnr003/)实现 **strStr()** 函数。",
                            "tag": "字符串,,",
                            "title": "实现 strStr()"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-string-5",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/字符串/整数反转.md",
                            "modifyTime": 1647101626858,
                            "postTime": 1647101626858,
                            "prev": "# [整数反转](https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnx13t/)    给你一个 32 位的有符号整数 ```x``` ，返回将 ```x``` 中的数字部分反转后的结果。如果反转后整数超过 32 位的有符号整数的范围 ```[−2^31,  2^31 − 1]``` ，就返回 0。",
                            "tag": "字符串,,",
                            "title": "整数反转"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-string-6",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/字符串/有效的字母异位词.md",
                            "modifyTime": 1647101659025,
                            "postTime": 1647101659025,
                            "prev": "# 有效的字符异位词给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。### 题解1",
                            "tag": "字符串,,",
                            "title": "有效的字母异位词"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-string-7",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/字符串/验证回文串.md",
                            "modifyTime": 1647101677113,
                            "postTime": 1647101677113,
                            "prev": "# 验证回文串给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。说明：本题中，我们将空字符串定义为有效的回文串。字符串除了字母与数字, 还会出现其他字符.",
                            "tag": "字符串,,",
                            "title": "验证回文串"
                        }
                    ],
                    "markdown": "LeetCode/初级算法/字符串/string.md",
                    "modifyTime": 1647102893150,
                    "postTime": 1647102893150,
                    "prev": " ",
                    "tag": ",",
                    "title": "字符串题目集"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-alg1-sortandsearch-0",
                    "items": [
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-sortandsearch-1",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/排序和搜索/合并两个有序数组.md",
                            "modifyTime": 1647101717707,
                            "postTime": 1647101717707,
                            "prev": "[原贴](https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnumcr/)给你两个有序整数数组 `nums1` 和 `nums2`，请你将 `nums2` 合并到 `nums1` 中，使 `nums1` 成为一个有序数组。初始化 `nums1` 和 `nums2` 的元素数量分别为 `m` 和 `n` 。你可以假设 `nums1` 的空间大小等于 `m + n`，这样它就有足够的空间保存来自 `nums2` 的元素。",
                            "tag": "搜索,排序,,",
                            "title": "合并两个有序数组"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-sortandsearch-2",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/排序和搜索/第一个错误的版本.md",
                            "modifyTime": 1647101727508,
                            "postTime": 1647101727508,
                            "prev": "[原贴](https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnto1s/)你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。假设你有 `n` 个版本 `[1, 2, ..., n]`，你想找出导致之后所有版本出错的第一个错误的版本。",
                            "tag": "搜索,排序,,",
                            "title": "第一个错误的版本"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-math-1",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/数学/罗马数字转整数.md",
                            "modifyTime": 1647101748293,
                            "postTime": 1647101748293,
                            "prev": "[原贴](https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn4n7c/)罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。]        字符          数值",
                            "tag": "数学,,",
                            "title": "罗马数字转整数"
                        }
                    ],
                    "markdown": "LeetCode/初级算法/排序和搜索/sortandsearch.md",
                    "modifyTime": 1647102911680,
                    "postTime": 1647102911680,
                    "prev": " ",
                    "tag": ",",
                    "title": "排序和搜索题目集"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-alg1-math-0",
                    "items": [
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-math-2",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/数学/计数质数.md",
                            "modifyTime": 1647101774149,
                            "postTime": 1647101774149,
                            "prev": "[原贴](https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnzlu6/)统计所有小于非负整数 `n` 的质数的数量.$0 < n < 5 x 10^{6}$",
                            "tag": "数学,,",
                            "title": "计数质数"
                        }
                    ],
                    "markdown": "LeetCode/初级算法/数学/math.md",
                    "modifyTime": 1647102920427,
                    "postTime": 1647102920427,
                    "prev": " ",
                    "tag": ",",
                    "title": "数学题目集"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-alg1-array-0",
                    "items": [
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-array-1",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/数组/两个数组的交集 II.md",
                            "modifyTime": 1647101799308,
                            "postTime": 1647101799308,
                            "prev": "# 两个数组的交集 II  给定两个数组，编写一个函数来计算它们的交集。  说明：",
                            "tag": "数组,,",
                            "title": "两个数组的交集 II"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-array-2",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/数组/两数之和.md",
                            "modifyTime": 1647101813202,
                            "postTime": 1647101813202,
                            "prev": "# 两数之和  ## 题目  给定一个整数数组 ```nums``` 和一个整数目标值 ```target```，请你在该数组中找出 **和为目标值** 的那 **两个** 整数，并返回它们的数组下标。",
                            "tag": "数组,,",
                            "title": "两数之和"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-array-3",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/数组/删除排序数组中的重复项 II.md",
                            "modifyTime": 1647101837468,
                            "postTime": 1647101837468,
                            "prev": "[原贴](https://leetcode-cn.com/leetbook/read/all-about-array/x9nivs/)给你一个有序数组 `nums` ，请你 **原地** 删除重复出现的元素，使每个元素 **最多出现两次** ，返回删除后数组的新长度。不要使用额外的数组空间，你必须在 **原地** 修改输入数组 并在使用 `O(1)` 额外空间的条件下完成。",
                            "tag": "数组,,",
                            "title": "删除排序数组中的重复项 II"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-array-4",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/数组/删除排序数组中的重复项.md",
                            "modifyTime": 1647101842368,
                            "postTime": 1647101842368,
                            "prev": "# 删除排序数组中的重复项  ## 题目  给定一个排序数组，你需要在 **原地** 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。",
                            "tag": "数组,,",
                            "title": "删除排序数组中的重复项"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-array-5",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/数组/加一.md",
                            "modifyTime": 1647101853072,
                            "postTime": 1647101853072,
                            "prev": "# 加一   ## 题目  给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。",
                            "tag": "数组,,",
                            "title": "加 一 "
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-array-6",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/数组/只出现一次的数字.md",
                            "modifyTime": 1647101867615,
                            "postTime": 1647101867615,
                            "prev": "# 只出现一次的数字  ## 题目    给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。",
                            "tag": "数组,,",
                            "title": "只出现一次的数字"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-array-7",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/数组/存在重复元素.md",
                            "modifyTime": 1647101876669,
                            "postTime": 1647101876668,
                            "prev": "# 存在重复元素  ## 题目    给定一个整数数组，判断是否存在重复元素。",
                            "tag": "数组,,",
                            "title": "存在的重复元素"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-array-8",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/数组/旋转图像.md",
                            "modifyTime": 1647101885868,
                            "postTime": 1647101885868,
                            "prev": "[原贴](https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnhhkv/)给定一个 n × n 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。你必须在 **原地** 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。",
                            "tag": "数组,,",
                            "title": "旋转图像"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-array-9",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/数组/旋转数组.md",
                            "modifyTime": 1647101892763,
                            "postTime": 1647101892763,
                            "prev": "# 旋转数组  ## 题目  给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。  ",
                            "tag": "数组,,",
                            "title": "旋转数组"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-array-10",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/数组/有效数独.md",
                            "modifyTime": 1647101907486,
                            "postTime": 1647101907486,
                            "prev": "[原贴](https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2f9gg/)判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。1. 数字 `1-9` 在每一行只能出现一次。",
                            "tag": "数组,,",
                            "title": "有效数独"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-array-11",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/数组/移动0.md",
                            "modifyTime": 1647101923626,
                            "postTime": 1647101923626,
                            "prev": "# 移动0    ## 题目  ",
                            "tag": "数组,,",
                            "title": "移动 0"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-array-12",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/数组/移除元素.md",
                            "modifyTime": 1647101933042,
                            "postTime": 1647101933042,
                            "prev": "[原贴](https://leetcode-cn.com/leetbook/read/all-about-array/x9p1iv/)给你一个数组 `nums` 和一个值 `val`，你需要 原地 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 **O(1)** 额外空间并 **原地** 修改输入数组。",
                            "tag": "数组,,",
                            "title": "移除元素"
                        }
                    ],
                    "markdown": "LeetCode/初级算法/数组/array.md",
                    "modifyTime": 1647102931796,
                    "postTime": 1647102931796,
                    "prev": " ",
                    "tag": ",",
                    "title": "数组题目集"
                },
                {
                    "author": "Smile Yik",
                    "id": "lc-alg1-linkedlist-0",
                    "items": [
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-linkedlist-1",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/链表/删除链表中的节点.md",
                            "modifyTime": 1647101961226,
                            "postTime": 1647101961226,
                            "prev": "[原贴](https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnarn7/)请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 **要被删除的节点** 。",
                            "tag": "链表,,",
                            "title": "删除链表中的节点"
                        },
                        {
                            "author": "Smile Yik",
                            "id": "lc-alg1-linkedlist-2",
                            "items": [
                            ],
                            "markdown": "LeetCode/初级算法/链表/反转链表.md",
                            "modifyTime": 1647101973307,
                            "postTime": 1647101973307,
                            "prev": "反转一个单链表### 解法1迭代",
                            "tag": "链表,,",
                            "title": "反转链表"
                        }
                    ],
                    "markdown": "LeetCode/初级算法/链表/linkedlist.md",
                    "modifyTime": 1647102943930,
                    "postTime": 1647102943930,
                    "prev": " ",
                    "tag": ",",
                    "title": "链表题目集"
                }
            ],
            "markdown": "LeetCode/初级算法/alg1.md",
            "modifyTime": 1647102798138,
            "postTime": 1647102798138,
            "prev": " ",
            "tag": ",",
            "title": "初级算法题目集"
        }
    ],
    "modifyTime": 1647100800964,
    "title": "LeetCode题目集"
}
