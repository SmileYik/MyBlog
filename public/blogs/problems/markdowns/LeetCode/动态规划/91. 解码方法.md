91. 解码方法

难度：中等

一条包含字母 A-Z 的消息通过以下映射进行了 **编码** ：

```
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
```


要 **解码** 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

- "AAJF" ，将消息分组为 (1 1 10 6)
- "KJF" ，将消息分组为 (11 10 6)


注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 **非空 **字符串 s ，请计算并返回 **解码** 方法的 **总数** 。

题目数据保证答案肯定是一个 **32 位** 的整数。



**示例 1：**

```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。

```


**示例 2：**

```
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。

```


**示例 3：**

```
输入：s = "0"
输出：0
解释：没有字符映射到以 0 开头的数字。
含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。

```




**提示：**

- 1 <= s.length <= 100
- s 只包含数字，并且可能包含前导零。


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/decode-ways/
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 题解

[跳转到题目](#main)

只有 1~26 数字才能组成一个字母, 0作为一个特殊数字, 它只能在10, 20时才能被解码, 在其他情况下他不能被解码成任何字母, 所以在初始化时, 如果首字母是0, 那么就没有可能进行解码了, 同理如果当遇到一个0时, 如果前一个数字不是1或者2, 那么他也不能被解码, 从而整串数字都不能被解码.

- 除此之外, 如果第n个数字与前一个数字组合起来是1~26数字之间的一个, 那么前n个数字能够被解码成的字符串有
  - 当$n \leq 2$时, 为前n-1个数字能够被解码的数量加1
  - 当$n > 2$ 时, 为前n-1个数字能够被解码的数量加上前n-2个数字能够被解码的数量

- 如果第n个数字与前一个数字并不在1~26之间内, 那么他能组成的数字只有前n-1个数字能够被解码的数量.

- 当数字为0时:
  - 如果前一个数字不为2或1, 则整个数字都不能被转译为字符串
  - 如果前一个数字为2或者1时, 前一个数字不能和前前一个数字进行组合, 而只能和后面一个数字(也就是0)进行组合, 这时候能够解码成为的字符串为前n-2能够解码的字符串数量.
    - 当n = 1时, n - 2 = -1, 显然是不可行的, 而n为1时, 也就是只有两个数字, 不是10就是20, 那么能够解码的字符也就只有1种.  

```java
class Solution {
    public int numDecodings(String s) {
      char[] chars = s.toCharArray();
      int[] dp = new int[chars.length];
      // init
      if (chars[0] != '0') {
        dp[0] = 1;
      } else {
        return 0;
      }

      for (int i = 1; i < chars.length; ++i) {
        if (chars[i] == '0') {
          if (chars[i - 1] >= '3' || chars[i - 1] == '0') {
            return 0;
          }
          dp[i] = (i == 1 ? dp[0] : dp[i - 2]);
        } else if (chars[i - 1] == '1' || chars[i - 1] == '2' && chars[i] <= '6') {
          dp[i] = (i <= 2 ? 1 : dp[i - 2]) + dp[i - 1];
        } else {
          dp[i] = dp[i - 1];
        }
      }
      return dp[chars.length - 1];
    }
}
```
